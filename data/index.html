<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AG do Caixeiro-Viajante • Editor Interativo</title>
    <link
      href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      :root {
        --bg-dark: #0f172a;
        --bg-light: #1e293b;
        --border-color: #334155;
        --text-primary: #e2e8f0;
        --text-secondary: #94a3b8;
        --accent-color: #2563eb;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          "Helvetica Neue", Arial;
        background: #0b0f19;
        color: var(--text-primary);
      }
      #app {
        display: grid;
        grid-template-rows: auto 1fr;
        height: 100vh;
      }
      header {
        display: flex;
        align-items: center;
        padding: 0.65rem 1.2rem;
        background: var(--bg-dark);
        border-bottom: 1px solid #0b1220;
      }
      header h1 {
        margin: 0;
        font-size: 1.1rem;
        letter-spacing: 0.2px;
      }

      .main-container {
        display: grid;
        grid-template-columns: 1fr 400px;
        height: 100%;
        overflow: hidden;
      }
      #map-container {
        position: relative;
        height: 100%;
      }
      #map {
        width: 100%;
        height: 100%;
        cursor: pointer;
      }
      #right-panel {
        background: var(--bg-dark);
        padding: 1rem;
        overflow-y: auto;
        border-left: 1px solid #0b1220;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .panel {
        position: absolute;
        top: 16px;
        left: 16px;
        z-index: 10;
        background: rgba(15, 23, 42, 0.9);
        backdrop-filter: blur(4px);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 14px;
        padding: 16px;
        box-shadow: 0 12px 28px rgba(0, 0, 0, 0.35);
        min-width: 350px;
      }
      .panel p {
        font-size: 0.85rem;
        color: var(--text-secondary);
        margin: 0 0 10px;
        line-height: 1.4;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
        margin-bottom: 0.35rem;
      }
      button {
        border: 0;
        border-radius: 10px;
        padding: 0.48rem 0.76rem;
        font-weight: 700;
        background: #374151;
        color: #fff;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      button.primary {
        background: var(--accent-color);
      }
      button:hover:not(:disabled) {
        opacity: 0.9;
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      label {
        font-size: 0.9rem;
      }
      .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        margin: 0.4rem 0;
      }
      .stat {
        background: #111827;
        border: 1px solid #1f2937;
        border-radius: 8px;
        padding: 0.35rem 0.55rem;
        font-variant-numeric: tabular-nums;
      }
      h2 {
        font-size: 1.1rem;
        margin: 0 0 10px 0;
        color: var(--text-secondary);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 8px;
      }

      .data-card {
        background: var(--bg-light);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 1rem;
      }
      .data-card h3 {
        margin: 0 0 1rem 0;
        font-size: 1rem;
        color: var(--text-primary);
      }
      #chart-container {
        position: relative;
        height: 250px;
      }
      #top-individuals-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.8rem;
      }
      #top-individuals-table th,
      #top-individuals-table td {
        padding: 6px;
        text-align: left;
        border-bottom: 1px solid var(--border-color);
      }
      #top-individuals-table th {
        color: var(--text-secondary);
      }
      #top-individuals-table .chromosome {
        font-family: monospace;
        word-break: break-all;
      }

      #city-legend {
        font-size: 0.8rem;
        columns: 2;
        column-gap: 1rem;
      }
      #city-legend p {
        margin: 4px 0;
        display: flex;
        align-items: center;
      }
      .legend-color-dot {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 8px;
        border: 1px solid rgba(0, 0, 0, 0.2);
      }

      /* Novo estilo para a seção de download */
      .download-section {
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px dashed var(--border-color);
      }
      .download-section .controls {
        justify-content: space-around;
      }
      .download-section p {
        margin-bottom: 8px;
      }
      /* Estilo para input number de largura pequena */
      .config-input {
        width: 80px;
        padding: 0.3rem;
        border-radius: 6px;
        background: #1f2937;
        color: white;
        border: 1px solid #374151;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <header><h1>AG TSP – Editor Interativo</h1></header>
      <main class="main-container">
        <div id="map-container">
          <div id="map"></div>
          <div class="panel">
            <div id="city-selection-panel">
              <h2>1. Monte seu Trajeto</h2>
              <p>
                <b>Adicionar:</b> Clique em um local vazio no mapa.<br />
                <b>Mover:</b> Clique e arraste um ponto existente.<br />
                <b>Remover:</b> Clique em um ponto existente.
              </p>
              <div
                class="row"
                style="justify-content: center; font-size: 1.1rem"
              >
                Cidades Definidas: <b id="city-count">0</b>
              </div>

              <div class="download-section">
                <p>Baixar dados do trajeto (Pontos > 2):</p>
                <div class="controls">
                  <button
                    id="btnDownloadDistances"
                    style="flex-grow: 1; min-width: 45%"
                  >
                    ⬇ Matriz de Distâncias (.csv)
                  </button>
                  <button
                    id="btnDownloadPoints"
                    style="flex-grow: 1; min-width: 45%"
                  >
                    ⬇ Pontos (.csv)
                  </button>
                </div>
              </div>

              <button
                id="btnConfirmCities"
                class="primary"
                style="width: 100%; margin-top: 10px"
              >
                Confirmar Cidades e Prosseguir
              </button>
            </div>

            <div id="ga-settings" style="display: none">
              <h2>2. Configure o Algoritmo</h2>
              <div class="row">
                <label for="popSize">Tamanho da População</label
                ><input
                  id="popSize"
                  type="number"
                  value="150"
                  min="10"
                  max="500"
                  step="10"
                  class="config-input"
                />
              </div>

              <div class="row">
                <label for="gensPerPlay">Gerações por Play</label
                ><input
                  id="gensPerPlay"
                  type="number"
                  min="1"
                  max="500"
                  step="1"
                  value="20"
                  class="config-input"
                />
              </div>

              <div class="row">
                <label for="mutRate">Taxa de Mutação (%)</label
                ><input
                  id="mutRate"
                  type="number"
                  min="0"
                  max="100"
                  step="1"
                  value="5"
                  class="config-input"
                />
              </div>
              <div class="row">
                <label for="chkElitism">Utilizar Elitismo</label
                ><input
                  id="chkElitism"
                  type="checkbox"
                  checked
                  style="width: 20px; height: 20px"
                />
              </div>
              <button
                id="btnStart"
                class="primary"
                style="width: 100%; margin-top: 15px"
              >
                Iniciar Simulação
              </button>
            </div>

            <div id="simulation-controls" style="display: none">
              <h2>3. Simulação em Andamento</h2>
              <div class="controls">
                <button id="btnPlay" class="primary">▶ Play</button>
                <button id="btnPause" class="secondary">⏸ Pausar</button>
                <button id="btnStep" class="secondary">⏭ 1 geração</button>
                <button id="btnReset" class="secondary">↺ Reiniciar</button>
              </div>
              <div class="row">
                <label for="displayMode">Modo de Exibição</label
                ><select
                  id="displayMode"
                  style="
                    padding: 0.3rem;
                    border-radius: 6px;
                    background: #1f2937;
                    color: white;
                    border: 1px solid #374151;
                    width: 180px;
                  "
                >
                  <option value="1">O melhor indivíduo</option>
                  <option value="2">Os 2 melhores</option>
                  <option value="5" selected>Os 5 melhores</option>
                  <option value="10">Os 10 melhores</option>
                  <option value="all">Toda a População</option>
                </select>
              </div>
              <div class="row">
                <label for="simTime">Tempo Máx. (por Play)</label
                ><select
                  id="simTime"
                  style="
                    padding: 0.3rem;
                    border-radius: 6px;
                    background: #1f2937;
                    color: white;
                    border: 1px solid #374151;
                    width: 180px;
                  "
                >
                  <option value="60" selected>1 Minuto</option>
                  <option value="120">2 Minutos</option>
                  <option value="0">Instantâneo</option>
                </select>
              </div>
              <div class="controls" style="gap: 0.75rem; margin-top: 10px">
                <span class="stat">Geração: <b id="statGen">0</b></span
                ><span class="stat"
                  >Melhor custo (km): <b id="statCost">–</b></span
                >
              </div>
            </div>
          </div>
        </div>
        <div id="right-panel" style="display: none">
          <div class="data-card">
            <h3>Convergência Genética</h3>
            <div id="chart-container">
              <canvas id="convergenceChart"></canvas>
            </div>
          </div>
          <div class="data-card">
            <h3>Top 10 Indivíduos (Geração Atual)</h3>
            <div id="top-individuals-table"></div>
          </div>
          <div class="data-card">
            <h3>Legenda das Cidades</h3>
            <div id="city-legend"></div>
          </div>
        </div>
      </main>
    </div>

    <script>
      let cfg = {};
      let population = [],
        costs = [],
        bestCost = Infinity,
        gen = 0,
        routeColors = [],
        history = [];
      let stopAnim = false,
        animationFrameId = null;
      let convergenceChart;
      const defaultCitiesTemplate = [
        { name: "Aracaju", lat: -10.9095421, lng: -37.0747732 },
        { name: "N. S. Socorro", lat: -10.855, lng: -37.1261 },
        { name: "São Cristóvão", lat: -11.0136465, lng: -37.2071134 },
        { name: "Itabaiana", lat: -10.6858763, lng: -37.4247007 },
        { name: "Lagarto", lat: -10.9145344, lng: -37.6638508 },
        { name: "Estância", lat: -11.2687119, lng: -37.4421355 },
        { name: "Propriá", lat: -10.230052, lng: -36.8394326 },
        { name: "Tobias Barreto", lat: -11.1839, lng: -37.9983 },
        { name: "N. S. Glória", lat: -10.2156554, lng: -37.4212807 },
        { name: "Canindé de S.F.", lat: -9.64194, lng: -37.78778 },
        { name: "Itaporanga", lat: -10.991997, lng: -37.3065 },
        { name: "Boquim", lat: -11.1415, lng: -37.61916 },
      ];
      let cities = [];
      let W;
      let isDragging = false;
      let draggedPointId = null;
      let cityColorPalette = [];
      let currentPhase = "city-selection";

      const SPRITES = {
        FLYING_0: "helicopter-flying-0",
        FLYING_1: "helicopter-flying-1",
        SHADOW_0: "shadow-helicopter-flying-0",
        SHADOW_1: "shadow-helicopter-flying-1",
        LAYER_HELICOPTER: "planes-symbols",
        LAYER_SHADOW: "planes-shadow",
      };
      let currentSpriteIndex = 0;
      let planeAnimationId = null;

      const map = new maplibregl.Map({
        container: "map",
        style: {
          version: 8,
          glyphs: "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
          sources: {
            osm: {
              type: "raster",
              tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
              tileSize: 256,
              attribution: "© OpenStreetMap",
            },
          },
          layers: [{ id: "osm", type: "raster", source: "osm" }],
        },
        center: [-37.19, -10.85],
        zoom: 7.2,
      });
      map.addControl(
        new maplibregl.NavigationControl({ visualizePitch: false }),
        "top-right"
      );

      function setPhase(phase) {
        currentPhase = phase;

        const isCitySelection = phase === "city-selection";

        document.getElementById("city-selection-panel").style.display =
          isCitySelection ? "block" : "none";
        document.getElementById("ga-settings").style.display =
          phase === "ga-settings" ? "block" : "none";
        document.getElementById("simulation-controls").style.display =
          phase === "simulation" ? "block" : "none";
        document.getElementById("right-panel").style.display =
          phase === "simulation" ? "flex" : "none";

        map.getCanvas().style.cursor = isCitySelection ? "pointer" : "";

        if (isCitySelection) {
          map.on("click", onMapClick);
          map.on("mousedown", "editable-cities-points", onMouseDown);

          cancelAnimationFrame(planeAnimationId);
        } else {
          map.off("click", onMapClick);
          map.off("mousedown", "editable-cities-points", onMouseDown);

          map.off("mousemove", onMouseMove);
          map.off("mouseup", onMouseUp);
          isDragging = false;
          draggedPointId = null;

          if (phase === "simulation") {
            if (!planeAnimationId) {
              animatePlanes(0);
            }
          }
        }

        const downloadButtons = document.querySelector(".download-section");
        if (downloadButtons) {
          const isDownloadEnabled = cities.length >= 3;
          downloadButtons.style.display =
            isDownloadEnabled && isCitySelection ? "block" : "none";
        }
      }

      function refreshEditableCities() {
        const cityFeatures = cities.map((c, idx) => ({
          type: "Feature",
          id: idx,
          properties: {
            name: c.name,
            id: idx,
            color: c.color,
          },
          geometry: { type: "Point", coordinates: [c.lng, c.lat] },
        }));
        map
          .getSource("editable-cities")
          .setData({ type: "FeatureCollection", features: cityFeatures });
        document.getElementById("city-count").textContent = cities.length;

        setPhase(currentPhase);
      }

      function onMapClick(e) {
        if (isDragging || currentPhase !== "city-selection") return;
        const features = map.queryRenderedFeatures(e.point, {
          layers: ["editable-cities-points"],
        });
        if (features.length > 0) {
          cities.splice(features[0].properties.id, 1);
        } else {
          const { lng, lat } = e.lngLat;
          const newColor =
            cityColorPalette[cities.length % cityColorPalette.length];
          cities.push({
            name: `Ponto ${cities.length}`,
            lat,
            lng,
            color: newColor,
          });
        }
        refreshEditableCities();
      }

      function onMouseDown(e) {
        if (currentPhase !== "city-selection") return;
        const features = map.queryRenderedFeatures(e.point, {
          layers: ["editable-cities-points"],
        });
        if (features.length === 0) return;
        isDragging = true;
        draggedPointId = features[0].properties.id;
        map.getCanvas().style.cursor = "grabbing";
        e.preventDefault();
        map.on("mousemove", onMouseMove);
        map.once("mouseup", onMouseUp);
      }

      function onMouseMove(e) {
        if (!isDragging || currentPhase !== "city-selection") return;
        const { lng, lat } = e.lngLat;
        cities[draggedPointId].lng = lng;
        cities[draggedPointId].lat = lat;
        refreshEditableCities();
      }

      function onMouseUp() {
        if (currentPhase !== "city-selection") return;
        isDragging = false;
        draggedPointId = null;
        map.getCanvas().style.cursor = "pointer";
        map.off("mousemove", onMouseMove);
      }

      function buildMatrix() {
        const n = cities.length;
        W = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++)
          for (let j = 0; j < n; j++) {
            W[i][j] = i === j ? 0 : haversineKm(cities[i], cities[j]);
          }
      }
      function haversineKm(a, b) {
        const R = 6371;
        const t = (x) => (x * Math.PI) / 180;
        const d = t(b.lat - a.lat);
        const l = t(b.lng - a.lng);
        const s =
          Math.sin(d / 2) ** 2 +
          Math.cos(t(a.lat)) * Math.cos(t(b.lat)) * Math.sin(l / 2) ** 2;
        return 2 * R * Math.asin(Math.sqrt(s));
      }

      /**
       * Calcula o bearing (rumo) em graus entre dois pontos de GPS.
       * Retorna um valor entre 0 e 360 graus (0 = Norte).
       * @param {{lat: number, lng: number}} start
       * @param {{lat: number, lng: number}} end
       * @returns {number} Rotação em graus.
       */
      function calculateBearing(start, end) {
        const lat1 = (start.lat * Math.PI) / 180;
        const lat2 = (end.lat * Math.PI) / 180;
        const lon1 = (start.lng * Math.PI) / 180;
        const lon2 = (end.lng * Math.PI) / 180;

        const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
        const x =
          Math.cos(lat1) * Math.sin(lat2) -
          Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

        let bearingRad = Math.atan2(y, x);
        let bearingDeg = (bearingRad * 180) / Math.PI;

        return (bearingDeg + 360) % 360;
      }

      function generateHslaColors(count, saturation, lightness, alpha) {
        let colors = [];

        let initialHue = 0;
        const hueStep = 360 / count;

        for (let i = 0; i < count; i++) {
          let hue = (initialHue + i * hueStep) % 360;
          colors.push(`hsla(${hue},${saturation}%,${lightness}%,${alpha})`);
        }
        return colors;
      }
      function randInt(n) {
        return Math.floor(Math.random() * n);
      }
      function initPop() {
        const n = cities.length;
        population = [];
        costs = [];
        gen = 0;
        bestCost = Infinity;
        bestRoute = null;
        history = [];
        for (let i = 0; i < cfg.popSize; i++) {
          const r = shuffle([...Array(n).keys()]);
          population.push(r);
          const c = routeCost(r);
          costs.push(c);
          if (c < bestCost) {
            bestCost = c;
            bestRoute = r.slice();
          }
        }
        updateStats();
      }
      function stepGen() {
        const e = cfg.elitism ? 2 : 0;
        const i = Array.from({ length: population.length }, (_, i) => i).sort(
          (a, b) => costs[a] - costs[b]
        );
        const l = i.slice(0, e).map((i) => population[i].slice());
        const nP = [...l];

        const mutProb = cfg.mutRate / 100;

        while (nP.length < cfg.popSize) {
          const p1 = tournament(population, 5);
          const p2 = tournament(population, 5);
          let [c1, c2] = Math.random() < 0.9 ? ox(p1, p2) : [p1, p2];

          if (Math.random() < mutProb) mutInv(c1);
          if (Math.random() < mutProb) mutInv(c2);

          nP.push(c1);
          if (nP.length < cfg.popSize) nP.push(c2);
        }
        population = nP;
        costs = population.map(routeCost);
        const gBI = costs.indexOf(Math.min(...costs));
        const gB = costs[gBI];
        if (gB < bestCost) {
          bestCost = gB;
          bestRoute = population[gBI].slice();
        }
        gen++;
        const avg = costs.reduce((a, b) => a + b, 0) / costs.length;
        history.push({ gen, best: gB, avg: avg });
        updateStats();
      }
      function routeCost(r) {
        if (!W || W.length === 0) return Infinity;
        let s = 0;
        for (let k = 0; k < r.length - 1; k++) s += W[r[k]][r[k + 1]];
        return s + W[r[r.length - 1]][r[0]];
      }
      function tournament(p, k) {
        let bI = -1,
          b = Infinity;
        for (let t = 0; t < k; t++) {
          const i = randInt(p.length);
          const c = costs[i];
          if (c < b) {
            b = c;
            bI = i;
          }
        }
        return p[bI].slice();
      }
      function ox(p1, p2) {
        const n = p1.length;
        let a = randInt(n),
          b = randInt(n);
        if (a > b) [a, b] = [b, a];
        const m = (A, B) => {
          const c = new Array(n).fill(null);
          c.splice(a, b - a + 1, ...A.slice(a, b + 1));
          const r = B.filter((g) => !c.includes(g));
          let i = 0;
          for (let j = 0; j < n; j++) if (c[j] === null) c[j] = r[i++];
          return c;
        };
        return [m(p1, p2), m(p2, p1)];
      }
      function mutInv(r) {
        let i = randInt(r.length),
          j = randInt(r.length);
        if (i > j) [i, j] = [j, i];
        r.splice(i, j - i + 1, ...r.slice(i, j + 1).reverse());
      }
      function shuffle(a) {
        for (let i = a.length - 1; i > 0; i--) {
          const j = randInt(i + 1);
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      /**
       * Alterna o ícone do helicóptero e força o redesenho do mapa
       * para criar a animação de sprite sheet.
       */
      let lastFrameTime = 0;
      const FRAME_RATE = 1000 / 10;

      function animatePlanes(timestamp) {
        if (!map.loaded()) {
          planeAnimationId = requestAnimationFrame(animatePlanes);
          return;
        }

        if (timestamp - lastFrameTime > FRAME_RATE) {
          currentSpriteIndex = 1 - currentSpriteIndex;
          lastFrameTime = timestamp;

          const iconName =
            currentSpriteIndex === 0 ? SPRITES.FLYING_0 : SPRITES.FLYING_1;
          const shadowName =
            currentSpriteIndex === 0 ? SPRITES.SHADOW_0 : SPRITES.SHADOW_1;

          if (map.getLayer(SPRITES.LAYER_HELICOPTER)) {
            map.setLayoutProperty(
              SPRITES.LAYER_HELICOPTER,
              "icon-image",
              iconName
            );
          }
          if (map.getLayer(SPRITES.LAYER_SHADOW)) {
            map.setLayoutProperty(
              SPRITES.LAYER_SHADOW,
              "icon-image",
              shadowName
            );
          }
        }

        planeAnimationId = requestAnimationFrame(animatePlanes);
      }

      const SPRITE_URLS = [
        { id: SPRITES.FLYING_0, url: "./img/flying-0.png" },
        { id: SPRITES.FLYING_1, url: "./img/flying-0.png" },
        { id: SPRITES.SHADOW_0, url: "./img/shadow-0.png" },
        { id: SPRITES.SHADOW_1, url: "./img/shadow-0.png" },
      ];

      function loadMapImages(callback) {
        let loadedCount = 0;
        const total = SPRITE_URLS.length;

        if (total === 0) return callback();

        SPRITE_URLS.forEach(({ id, url }) => {
          map.loadImage(url, (error, image) => {
            if (error) {
              console.error(`Erro ao carregar imagem ${id}:`, error);
            } else {
              map.addImage(id, image, { pixelRatio: 1, sdf: false });
              loadedCount++;
            }

            if (loadedCount === total) {
              callback();
            }
          });
        });
      }

      function ensureLayers() {
        if (!map.getSource("routes"))
          map.addSource("routes", {
            type: "geojson",
            data: { type: "FeatureCollection", features: [] },
          });
        if (!map.getLayer("routes-lines"))
          map.addLayer({
            id: "routes-lines",
            type: "line",
            source: "routes",
            layout: {},
            paint: {
              "line-width": ["get", "lineWidth"],
              "line-opacity": 0.7,
              "line-color": ["get", "color"],
            },
          });
        if (!map.getSource("planes"))
          map.addSource("planes", {
            type: "geojson",
            data: { type: "FeatureCollection", features: [] },
          });

        if (!map.getLayer(SPRITES.LAYER_SHADOW))
          map.addLayer({
            id: SPRITES.LAYER_SHADOW,
            type: "symbol",
            source: "planes",
            layout: {
              "icon-image": SPRITES.SHADOW_0,
              "icon-size": ["get", "iconSize"],
              "icon-allow-overlap": true,
              "icon-offset": [0, 8],
              "icon-rotate": ["get", "rotation"],
              "icon-rotation-alignment": "map",
            },
          });

        if (!map.getLayer(SPRITES.LAYER_HELICOPTER))
          map.addLayer({
            id: SPRITES.LAYER_HELICOPTER,
            type: "symbol",
            source: "planes",
            layout: {
              "icon-image": SPRITES.FLYING_0,
              "icon-size": ["get", "iconSize"],
              "icon-allow-overlap": true,
              "icon-rotate": ["get", "rotation"],
              "icon-rotation-alignment": "map",
            },
          });
      }

      function getPopulationToDisplay() {
        const m = document.getElementById("displayMode").value;
        if (m === "all") {
          return population.map((ind, i) => ({
            individual: ind,
            originalIndex: i,
          }));
        }
        const c = parseInt(m, 10);
        const iP = population.map((ind, i) => ({
          individual: ind,
          cost: costs[i],
          originalIndex: i,
        }));
        iP.sort((a, b) => a.cost - b.cost);
        return iP.slice(0, c);
      }
      function updateDisplay() {
        ensureLayers();
        const p = getPopulationToDisplay();
        drawRoutes(p);
        updateTopIndividualsTable();
      }
      function drawRoutes(p) {
        const s = p.length === 1;
        const rF = p.map(({ individual: ind, originalIndex: oI }) => {
          const co = ind
            .concat(ind[0])
            .map((i) => [cities[i].lng, cities[i].lat]);
          return {
            type: "Feature",
            properties: {
              color: s ? "#f43f5e" : routeColors[oI],
              lineWidth: s ? 4 : 2,
            },
            geometry: { type: "LineString", coordinates: co },
          };
        });
        map
          .getSource("routes")
          .setData({ type: "FeatureCollection", features: rF });
        const pF = p.map(({ individual: ind }) => {
          const rotation = 0;
          const co = [cities[ind[0]].lng, cities[ind[0]].lat];
          return {
            type: "Feature",
            properties: { iconSize: s ? 0.6 : 0.5, rotation: rotation },
            geometry: { type: "Point", coordinates: co },
          };
        });
        map
          .getSource("planes")
          .setData({ type: "FeatureCollection", features: pF });
      }
      function animatePopulation(p, d) {
        if (d === 0) return Promise.resolve();
        const s = p.length === 1;
        let aS = p.map(({ individual: ind }) => ({
          route: ind.concat(ind[0]),
          sI: 0,
          prog: 0,
        }));
        const sD = d / cities.length;
        let sT = null;
        return new Promise((res) => {
          function animStep(t) {
            if (stopAnim) {
              res();
              return;
            }
            if (!sT) sT = t;
            const e = t - sT;
            const pF = aS.map((st) => {
              st.prog = e / sD;
              st.sI = Math.floor(st.prog);

              let rotation = 0;
              let currentCoords;
              let currentCity, nextCity;

              if (st.sI >= st.route.length - 1) {
                currentCity = cities[st.route[st.route.length - 1]];
                nextCity = cities[st.route[0]];

                currentCoords = [currentCity.lng, currentCity.lat];

                rotation = calculateBearing(currentCity, nextCity);
              } else {
                currentCity = cities[st.route[st.sI]];
                nextCity = cities[st.route[st.sI + 1]];
                const sP = st.prog - st.sI;

                const lng =
                  currentCity.lng + (nextCity.lng - currentCity.lng) * sP;
                const lat =
                  currentCity.lat + (nextCity.lat - currentCity.lat) * sP;

                currentCoords = [lng, lat];

                rotation = calculateBearing(currentCity, nextCity);
              }

              return {
                type: "Feature",
                properties: {
                  iconSize: s ? 0.6 : 0.5,
                  rotation: rotation,
                },
                geometry: { type: "Point", coordinates: currentCoords },
              };
            });
            map
              .getSource("planes")
              .setData({ type: "FeatureCollection", features: pF });
            if (e < d) {
              animationFrameId = requestAnimationFrame(animStep);
            } else {
              res();
            }
          }
          animationFrameId = requestAnimationFrame(animStep);
        });
      }
      function initConvergenceChart() {
        const c = document.getElementById("convergenceChart").getContext("2d");
        if (convergenceChart) convergenceChart.destroy();
        convergenceChart = new Chart(c, {
          type: "line",
          data: {
            labels: [],
            datasets: [
              {
                label: "Melhor Custo (km)",
                data: [],
                borderColor: "#f43f5e",
                tension: 0.1,
                borderWidth: 2,
              },
              {
                label: "Custo Médio (km)",
                data: [],
                borderColor: "#3b82f6",
                tension: 0.1,
                borderWidth: 1.5,
                borderDash: [5, 5],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            color: "#94a3b8",
            scales: {
              x: { ticks: { color: "#94a3b8" } },
              y: { ticks: { color: "#94a3b8" } },
            },
          },
        });
      }
      function updateConvergenceChart() {
        if (!convergenceChart || history.length === 0) return;
        const l = history[history.length - 1];
        convergenceChart.data.labels.push(l.gen);
        convergenceChart.data.datasets[0].data.push(l.best);
        convergenceChart.data.datasets[1].data.push(l.avg);
        convergenceChart.update();
      }
      function updateTopIndividualsTable() {
        const t = document.getElementById("top-individuals-table");
        const top10 = getPopulationToDisplay().slice(0, 10);
        let h =
          "<table><tr><th>#</th><th>Custo (km)</th><th>Cromossomo (Rota)</th></tr>";
        top10.forEach(({ individual: ind, cost: c }, i) => {
          const s = ind.join(" → ");
          h += `<tr><td>${i + 1}</td><td>${c.toFixed(
            2
          )}</td><td class="chromosome">${s}</td></tr>`;
        });
        h += "</table>";
        t.innerHTML = h;
      }
      function createCityLegend() {
        const l = document.getElementById("city-legend");
        let h = "";
        cities.forEach((c, i) => {
          h += `<p><span class="legend-color-dot" style="background-color: ${
            c.color
          };"></span><b>${i}</b>: ${c.name || `Ponto ${i}`}</p>`;
        });
        l.innerHTML = h;
      }
      function updateStats() {
        document.getElementById("statGen").textContent = String(gen);
        document.getElementById("statCost").textContent =
          bestCost === Infinity ? "–" : bestCost.toFixed(2);
      }

      function setControlsState(isPlaying) {
        document.getElementById("btnPlay").disabled = isPlaying;
        document.getElementById("btnStep").disabled = isPlaying;
        document.getElementById("btnPause").disabled = !isPlaying;
      }

      /**
       * Gera o conteúdo CSV para os pontos (cidades).
       * @returns {string} Conteúdo CSV.
       */
      function generatePointsCsv() {
        const header = "Indice,Nome,Latitude,Longitude";
        const rows = cities.map((city, index) => {
          const name = `"${city.name.replace(/"/g, '""')}"`;
          return `${index},${name},${city.lat.toFixed(8)},${city.lng.toFixed(
            8
          )}`;
        });
        return [header, ...rows].join("\n");
      }

      /**
       * Gera o conteúdo CSV para a matriz de distâncias.
       * Requer que a matriz W tenha sido calculada (buildMatrix).
       * @returns {string} Conteúdo CSV.
       */
      function generateDistancesCsv() {
        if (!W || W.length === 0) {
          buildMatrix();
        }

        const n = W.length;

        const header = "Origem/Destino," + [...Array(n).keys()].join(",");

        const rows = W.map((row, rowIndex) => {
          const rowData = row.map((distance) => distance.toFixed(2));
          return `${rowIndex},${rowData.join(",")}`;
        });

        return [header, ...rows].join("\n");
      }

      /**
       * Cria e dispara o download de um arquivo.
       * @param {string} filename Nome do arquivo.
       * @param {string} text Conteúdo do arquivo.
       */
      function downloadFile(filename, text) {
        const element = document.createElement("a");
        element.setAttribute(
          "href",
          "data:text/csv;charset=utf-8," + encodeURIComponent(text)
        );
        element.setAttribute("download", filename);
        element.style.display = "none";
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      }

      document
        .getElementById("btnConfirmCities")
        .addEventListener("click", () => {
          if (cities.length < 3) {
            console.error(
              "Por favor, defina pelo menos 3 cidades para o trajeto."
            );
            return;
          }

          buildMatrix();
          setPhase("ga-settings");
        });

      document
        .getElementById("btnDownloadDistances")
        .addEventListener("click", () => {
          if (cities.length < 3) {
            console.error(
              "É necessário pelo menos 3 cidades para gerar a Matriz de Distâncias."
            );
            return;
          }
          buildMatrix();
          const csvContent = generateDistancesCsv();
          downloadFile("matriz_distancias.csv", csvContent);
        });

      document
        .getElementById("btnDownloadPoints")
        .addEventListener("click", () => {
          if (cities.length < 1) {
            console.error("Não há pontos definidos para download.");
            return;
          }
          const csvContent = generatePointsCsv();
          downloadFile("pontos_caixeiro_viajante.csv", csvContent);
        });

      document.getElementById("btnStart").addEventListener("click", () => {
        cfg.popSize =
          parseInt(document.getElementById("popSize").value, 10) || 150;
        cfg.gensPerPlay =
          parseInt(document.getElementById("gensPerPlay").value, 10) || 20;
        cfg.mutRate =
          parseInt(document.getElementById("mutRate").value, 10) || 30;
        cfg.elitism = document.getElementById("chkElitism").checked;

        initPop();
        routeColors = generateHslaColors(cfg.popSize, 100, 60, 0.9);
        initConvergenceChart();
        createCityLegend();
        updateDisplay();
        setControlsState(false);
        setPhase("simulation");
      });
      document.getElementById("btnPlay").addEventListener("click", async () => {
        const b = cfg.gensPerPlay;
        const t = Number(document.getElementById("simTime").value);
        stopAnim = false;
        setControlsState(true);
        let d = t > 0 ? (t * 1000) / b : 0;
        for (let i = 0; i < b; i++) {
          if (stopAnim) break;
          stepGen();
          const p = getPopulationToDisplay();
          updateDisplay();
          updateConvergenceChart();
          await animatePopulation(p, d);
        }
        updateDisplay();
        setControlsState(false);
      });
      document.getElementById("btnStep").addEventListener("click", async () => {
        stopAnim = false;
        setControlsState(true);
        stepGen();
        const p = getPopulationToDisplay();
        updateDisplay();
        updateConvergenceChart();
        await animatePopulation(p, 2000);
        setControlsState(false);
      });
      document.getElementById("btnPause").addEventListener("click", () => {
        stopAnim = true;
        cancelAnimationFrame(animationFrameId);
        setControlsState(false);
      });
      document.getElementById("btnReset").addEventListener("click", () => {
        stopAnim = true;
        cancelAnimationFrame(planeAnimationId);
        cancelAnimationFrame(animationFrameId);
        const e = { type: "FeatureCollection", features: [] };
        if (map.getSource("routes")) map.getSource("routes").setData(e);
        if (map.getSource("planes")) map.getSource("planes").setData(e);
        if (map.getSource("editable-cities"))
          map.getSource("editable-cities").setData(e);
        cities = defaultCitiesTemplate.map((c, i) => ({
          ...c,
          color: cityColorPalette[i % cityColorPalette.length],
        }));
        W = undefined;
        refreshEditableCities();

        setPhase("city-selection");
      });
      document
        .getElementById("displayMode")
        .addEventListener("change", updateDisplay);

      map.on("load", () => {
        cityColorPalette = generateHslaColors(50, 95, 55, 1);

        map.addSource("editable-cities", {
          type: "geojson",
          data: { type: "FeatureCollection", features: [] },
        });
        map.addLayer({
          id: "editable-cities-points",
          type: "circle",
          source: "editable-cities",
          paint: {
            "circle-radius": 8,
            "circle-color": ["get", "color"],
            "circle-stroke-color": "#ffffff",
            "circle-stroke-width": 2,
          },
        });

        loadMapImages(() => {
          ensureLayers();
          cities = defaultCitiesTemplate.map((c, i) => ({
            ...c,
            color: cityColorPalette[i % cityColorPalette.length],
          }));
          refreshEditableCities();

          setPhase("city-selection");
        });
      });
    </script>
  </body>
</html>
